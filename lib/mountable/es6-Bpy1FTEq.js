var de=Object.defineProperty;var J=c=>{throw TypeError(c)};var me=(c,y,d)=>y in c?de(c,y,{enumerable:!0,configurable:!0,writable:!0,value:d}):c[y]=d;var S=(c,y,d)=>me(c,typeof y!="symbol"?y+"":y,d),pe=(c,y,d)=>y.has(c)||J("Cannot "+d);var K=(c,y,d)=>y.has(c)?J("Cannot add the same private member more than once"):y instanceof WeakSet?y.add(c):y.set(c,d),Q=(c,y,d,v)=>(pe(c,y,"write to private field"),v?v.call(c,d):y.set(c,d),d);let Z,L,E,ue=(async()=>{var x,G,$,V,Y,X;const c=globalThis.showDirectoryPicker;async function y(n={}){if(c&&!n._preferPolyfill)return c(n);const t=document.createElement("input");t.type="file",t.webkitdirectory=!0,t.multiple=!0,t.style.position="fixed",t.style.top="-100000px",t.style.left="-100000px",document.body.appendChild(t);const e=Promise.resolve().then(()=>B);return await new Promise(a=>{t.addEventListener("change",a),t.click()}),e.then(a=>a.getDirHandlesFromInput(t))}const d={accepts:[]},v=globalThis.showOpenFilePicker;async function ee(n={}){const t={...d,...n};if(v&&!n._preferPolyfill)return v(t);const e=document.createElement("input");e.type="file",e.multiple=t.multiple,e.accept=(t.accepts||[]).map(r=>[...(r.extensions||[]).map(o=>"."+o),...r.mimeTypes||[]]).flat().join(","),Object.assign(e.style,{position:"fixed",top:"-100000px",left:"-100000px"}),document.body.appendChild(e);const a=Promise.resolve().then(()=>B);return await new Promise(r=>{e.addEventListener("change",r,{once:!0}),e.click()}),e.remove(),a.then(r=>r.getFileHandlesFromInput(e))}const q=globalThis.showSaveFilePicker;async function te(n={}){if(q&&!n._preferPolyfill)return q(n);n._name&&(console.warn("deprecated _name, spec now have `suggestedName`"),n.suggestedName=n._name);const{FileSystemFileHandle:t}=await Promise.resolve().then(()=>h),{FileHandle:e}=await import("./downloader-Bh2ibQIr.js");return new t(new e(n.suggestedName))}globalThis.DataTransferItem&&!DataTransferItem.prototype.getAsFileSystemHandle&&(DataTransferItem.prototype.getAsFileSystemHandle=async function(){const n=this.webkitGetAsEntry(),[{FileHandle:t,FolderHandle:e},{FileSystemDirectoryHandle:a},{FileSystemFileHandle:r}]=await Promise.all([import("./sandbox-DdDgeYvH.js"),Promise.resolve().then(()=>O),Promise.resolve().then(()=>h)]);return n.isFile?new r(new t(n,!1)):new a(new e(n,!1))});async function ae(n,t={}){var o,s;if(!n)return((s=(o=globalThis.navigator)==null?void 0:o.storage)==null?void 0:s.getDirectory())||globalThis.getOriginPrivateDirectory();const{FileSystemDirectoryHandle:e}=await Promise.resolve().then(()=>O),a=await n,r=await(a.default?a.default(t):a(t));return new e(r)}let z;L={ReadableStream:globalThis.ReadableStream,WritableStream:globalThis.WritableStream,TransformStream:globalThis.TransformStream,DOMException:globalThis.DOMException,Blob:globalThis.Blob,File:globalThis.File},{WritableStream:z}=L;const N=class N extends z{constructor(e){super(e);K(this,x);Q(this,x,e),Object.setPrototypeOf(this,N.prototype),this._closed=!1}async close(){this._closed=!0;const e=this.getWriter(),a=e.close();return e.releaseLock(),a}seek(e){return this.write({type:"seek",position:e})}truncate(e){return this.write({type:"truncate",size:e})}write(e){if(this._closed)return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));const a=this.getWriter(),r=a.write(e);return a.releaseLock(),r}};x=new WeakMap;let F=N;Object.defineProperty(F.prototype,Symbol.toStringTag,{value:"FileSystemWritableFileStream",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(F.prototype,{close:{enumerable:!0},seek:{enumerable:!0},truncate:{enumerable:!0},write:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable&&!globalThis.FileSystemWritableFileStream&&(globalThis.FileSystemWritableFileStream=F);const j=F,u=Symbol("adapter");G=u;class R{constructor(t){S(this,G);S(this,"name");S(this,"kind");this.kind=t.kind,this.name=t.name,this[u]=t}async queryPermission(t={}){const{mode:e="read"}=t,a=this[u];if(a.queryPermission)return a.queryPermission({mode:e});if(e==="read")return"granted";if(e==="readwrite")return a.writable?"granted":"denied";throw new TypeError(`Mode ${e} must be 'read' or 'readwrite'`)}async requestPermission({mode:t="read"}={}){const e=this[u];if(e.requestPermission)return e.requestPermission({mode:t});if(t==="read")return"granted";if(t==="readwrite")return e.writable?"granted":"denied";throw new TypeError(`Mode ${t} must be 'read' or 'readwrite'`)}async remove(t={}){await this[u].remove(t)}async isSameEntry(t){return this===t?!0:!t||typeof t!="object"||this.kind!==t.kind||!t[u]?!1:this[u].isSameEntry(t[u])}}Object.defineProperty(R.prototype,Symbol.toStringTag,{value:"FileSystemHandle",writable:!1,enumerable:!1,configurable:!0}),globalThis.FileSystemHandle&&(($=globalThis.FileSystemHandle.prototype).queryPermission??($.queryPermission=function(n){return"granted"}));let D,U;D=R,E={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:n=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${n}`,"SyntaxError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},U={writable:globalThis.WritableStream};async function ie(n){console.warn("deprecated fromDataTransfer - use `dt.items[0].getAsFileSystemHandle()` instead");const[t,e,a]=await Promise.all([import("./memory-SZtOPQKJ.js"),import("./sandbox-DdDgeYvH.js"),Promise.resolve().then(()=>O)]),r=new t.FolderHandle("",!1);return r._entries=n.map(o=>o.isFile?new e.FileHandle(o,!1):new e.FolderHandle(o,!1)),new a.FileSystemDirectoryHandle(r)}async function re(n){const{FolderHandle:t,FileHandle:e}=await import("./memory-SZtOPQKJ.js"),{FileSystemDirectoryHandle:a}=await Promise.resolve().then(()=>O),r=Array.from(n.files),o=r[0].webkitRelativePath.split("/",1)[0],s=new t(o,!1);return r.forEach(p=>{const l=p.webkitRelativePath.split("/");l.shift();const m=l.pop(),f=l.reduce((b,g)=>(b._entries[g]||(b._entries[g]=new t(g,!1)),b._entries[g]),s);f._entries[m]=new e(p.name,p,!1)}),new a(s)}async function ne(n){const{FileHandle:t}=await import("./memory-SZtOPQKJ.js"),{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);return Array.from(n.files).map(a=>new e(new t(a.name,a,!1)))}const B=Object.freeze(Object.defineProperty({__proto__:null,config:U,errors:E,fromDataTransfer:ie,getDirHandlesFromInput:re,getFileHandlesFromInput:ne},Symbol.toStringTag,{value:"Module"})),{GONE:oe,MOD_ERR:se}=E,w=Symbol("adapter");let P=class M extends D{constructor(e){super(e);S(this,V);this[w]=e}async getDirectoryHandle(e,a={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");a.create=!!a.create;const r=await this[w].getDirectoryHandle(e,a);return new M(r)}async*entries(){const{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);for await(const[a,r]of this[w].entries())yield[r.name,r.kind==="file"?new e(r):new M(r)]}async*getEntries(){const{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);console.warn("deprecated, use .entries() instead");for await(let a of this[w].entries())yield a.kind==="file"?new e(a):new M(a)}async getFileHandle(e,a={}){const{FileSystemFileHandle:r}=await Promise.resolve().then(()=>h);if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");a.create=!!a.create;const o=await this[w].getFileHandle(e,a);return new r(o)}async removeEntry(e,a={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");return a.recursive=!!a.recursive,this[w].removeEntry(e,a)}async resolve(e){if(await e.isSameEntry(this))return[];const a=[{handle:this,path:[]}];for(;a.length;){let{handle:r,path:o}=a.pop();for await(const s of r.values()){if(await s.isSameEntry(e))return[...o,s.name];s.kind==="directory"&&a.push({handle:s,path:[...o,s.name]})}}return null}async*keys(){for await(const[e]of this[w].entries())yield e}async*values(){for await(const[e,a]of this)yield a}[(V=w,Symbol.asyncIterator)](){return this.entries()}};if(Object.defineProperty(P.prototype,Symbol.toStringTag,{value:"FileSystemDirectoryHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(P.prototype,{getDirectoryHandle:{enumerable:!0},entries:{enumerable:!0},getFileHandle:{enumerable:!0},removeEntry:{enumerable:!0}}),globalThis.FileSystemDirectoryHandle){const n=globalThis.FileSystemDirectoryHandle.prototype;n.resolve=async function(r){if(await r.isSameEntry(this))return[];const o=[{handle:this,path:[]}];for(;o.length;){let{handle:s,path:p}=o.pop();for await(const l of s.values()){if(await l.isSameEntry(r))return[...p,l.name];l.kind==="directory"&&o.push({handle:l,path:[...p,l.name]})}}return null};async function t(r){if(await(await navigator.storage.getDirectory()).resolve(r)===null)throw new DOMException(...oe)}const e=n.entries;n.entries=async function*(){await t(this),yield*e.call(this)},n[Symbol.asyncIterator]=async function*(){yield*this.entries()};const a=n.removeEntry;n.removeEntry=async function(r,o={}){return a.call(this,r,o).catch(async s=>{throw s instanceof DOMException&&s.name==="UnknownError"&&!o.recursive&&!(await e.call(this).next()).done?new DOMException(...se):s})}}const C=P,O=Object.freeze(Object.defineProperty({__proto__:null,FileSystemDirectoryHandle:P,default:C},Symbol.toStringTag,{value:"Module"})),{INVALID:le,SYNTAX:I,GONE:ce}=E,k=Symbol("adapter");class _ extends(X=D,Y=k,X){constructor(e){super(e);S(this,Y);this[k]=e}async createWritable(e={}){return new j(await this[k].createWritable(e))}async getFile(){return this[k].getFile()}}if(Object.defineProperty(_.prototype,Symbol.toStringTag,{value:"FileSystemFileHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(_.prototype,{createWritable:{enumerable:!0},getFile:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable){const n=new WeakMap;let t;const e=()=>{let r,o;onmessage=async s=>{const p=s.ports[0],l=s.data;switch(l.type){case"open":const m=l.name;let f=await navigator.storage.getDirectory();for(const b of l.path)f=await f.getDirectoryHandle(b);r=await f.getFileHandle(m),o=await r.createSyncAccessHandle();break;case"write":o.write(l.data,{at:l.position}),o.flush();break;case"truncate":o.truncate(l.size);break;case"abort":case"close":o.close();break}p.postMessage(0)}};globalThis.FileSystemFileHandle.prototype.createWritable=async function(r){if(!t){const i=`(${e.toString()})()`,T=new Blob([i],{type:"text/javascript"});t=URL.createObjectURL(T)}const o=new Worker(t,{type:"module"});let s=0;const p=new TextEncoder;let l=await this.getFile().then(i=>i.size);const m=i=>new Promise((T,ye)=>{const H=new MessageChannel;H.port1.onmessage=W=>{W.data instanceof Error?ye(W.data):T(W.data),H.port1.close(),H.port2.close(),H.port1.onmessage=null},o.postMessage(i,[H.port2])}),f=await navigator.storage.getDirectory(),b=await n.get(this),g=await f.resolve(b);if(g===null)throw new DOMException(...ce);return await m({type:"open",path:g,name:this.name}),(r==null?void 0:r.keepExistingData)===!1&&(await m({type:"truncate",size:0}),l=0),new j({start:i=>{},async write(i){if((i==null?void 0:i.constructor)===Object?i={...i}:i={type:"write",data:i,position:s},i.type==="write"){if(!("data"in i))throw await m({type:"close"}),new DOMException(...I("write requires a data argument"));if(i.position??(i.position=s),typeof i.data=="string")i.data=p.encode(i.data);else if(i.data instanceof ArrayBuffer)i.data=new Uint8Array(i.data);else if(!(i.data instanceof Uint8Array)&&ArrayBuffer.isView(i.data))i.data=new Uint8Array(i.data.buffer,i.data.byteOffset,i.data.byteLength);else if(!(i.data instanceof Uint8Array)){const T=await new Response(i.data).arrayBuffer();i.data=new Uint8Array(T)}Number.isInteger(i.position)&&i.position>=0&&(s=i.position),s+=i.data.byteLength,l+=i.data.byteLength}else if(i.type==="seek")if(Number.isInteger(i.position)&&i.position>=0){if(l<i.position)throw new DOMException(...le);console.log("seeking",i),s=i.position;return}else throw await m({type:"close"}),new DOMException(...I("seek requires a position argument"));else if(i.type==="truncate")if(Number.isInteger(i.size)&&i.size>=0)l=i.size,s>l&&(s=l);else throw await m({type:"close"}),new DOMException(...I("truncate requires a size argument"));await m(i)},async close(){await m({type:"close"}),o.terminate()},async abort(i){await m({type:"abort",reason:i}),o.terminate()}})};const a=FileSystemDirectoryHandle.prototype.getFileHandle;FileSystemDirectoryHandle.prototype.getFileHandle=async function(...r){const o=await a.call(this,...r);return n.set(o,this),o}}let A,h;A=_,h=Object.freeze(Object.defineProperty({__proto__:null,FileSystemFileHandle:_,default:A},Symbol.toStringTag,{value:"Module"})),Z=Object.freeze(Object.defineProperty({__proto__:null,FileSystemDirectoryHandle:C,FileSystemFileHandle:A,FileSystemHandle:D,FileSystemWritableFileStream:j,getOriginPrivateDirectory:ae,showDirectoryPicker:y,showOpenFilePicker:ee,showSaveFilePicker:te},Symbol.toStringTag,{value:"Module"}))})();export{ue as __tla,Z as a,L as c,E as e};
